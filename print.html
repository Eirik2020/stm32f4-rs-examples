<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Embedded Rust on the STM32F4 for dummies</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Embedded Rust on the STM32F4 for dummies</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Learning embedded rust has been quite the frustrating experiance for me, a lot of outdated documentation. Therefor, I intend to expand that pile!</p>
<p>This is a guide on how to do embedded rust on the NUCLEO-F401RE, using embedded HAL and defmt. If you are using a different microcontroller or debugger, you are out of luck, sorry not sorry!</p>
<p>The book is broken up into a set-up, some examples of common tasks and hopefully some deep-dives in the future!.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set-up"><a class="header" href="#set-up">Set-up</a></h1>
<h2 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h2>
<p>You already have installed rust and VS Code.
Maybe Windows 11.</p>
<h2 id="software"><a class="header" href="#software">Software</a></h2>
<p>Install the rust tool chain</p>
<pre><code class="language-sh">rustup install stable
rustup component add rust-src llvm-tools-preview
</code></pre>
<p>Install ARM Cortex-M target for STM32F4 series (Cortex-M4F with floating point unit (FPU))</p>
<pre><code class="language-sh">rustup target add thumbv7em-none-eabihf
</code></pre>
<p>Install Probe-RS as our debugger probe.</p>
<pre><code class="language-sh">cargo install probe-run
cargo install flip-link defmt-cli
</code></pre>
<p>Install cargo tools for embedded use</p>
<pre><code class="language-sh">cargo install cargo-embed
</code></pre>
<p><em>I also recommend installing the following VS Code Extentions:</em></p>
<ul>
<li>rust-analyzer</li>
<li>probe-rs-tools</li>
</ul>
<h2 id="hardware"><a class="header" href="#hardware">Hardware</a></h2>
<figure>
  <img src="images/NUCLEO-F401RE.jpg" alt="Description" width="600">
  <figcaption>Figure 1: The ST NUCLEO-F401RE development board, this is your wife now.</figcaption>
</figure>
<p>You will need a ST NUCLEO-F401RE, is equivalent.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>Here is a list of examples to show how to do most basic stuff in embedded rust.</p>
<p>These examples are available on my Github Repo, <code>stm32f4-rs-examples</code>, and can be cloned with:</p>
<pre><code class="language-sh">git clone https://github.com/Eirik2020/stm32f4-rs-examples.git
</code></pre>
<p>Then opened with:</p>
<pre><code class="language-sh">code stm32f4-rs-examples
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-purpose-io"><a class="header" href="#general-purpose-io">General Purpose IO</a></h1>
<p>This chapter covers GPIO, and some common applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world-in-embedded-rust"><a class="header" href="#hello-world-in-embedded-rust">Hello World! In embedded rust!</a></h1>
<p>To print hello world to the user, we need a way to send serial messages, in this case we use the debugger probe-rs with defmt. You might say, but what about other debuggers like GBD or openOCD?
My answer is no, here we are going full rust, or get scuffed.</p>
<p>Add the debugger to our dependencies in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">Cargo.toml
[dependencies]
defmt = "1.0.1"
defmt-rtt = "1.0.0"
panic-probe = { version = "1.0.0", features = ["print-defmt"] }
</code></pre>
<p>Then we import the debugger into our main function, and use <code>info!</code> to to send a message to the terminal:</p>
<pre><pre class="playground"><code class="language-rust">main.rs
// Import defmt debugger
use defmt::*;         // Debugger
use defmt_rtt as _;   // Use defmt as global rtt logger
use panic_probe as _; // Panic handler with defmt support

#[entry] 
fn main() -&gt; ! {
    // Use info! to print a message to the terminal. 
    info!("Hello World!");

    loop {}
}</code></pre></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<p>Here is a complete code example, it is the default example, and can be run with:</p>
<pre><code class="language-sh">$ cargo build
$ cargo embed
</code></pre>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

// Crates
use cortex_m_rt::entry; // ARM dependencies for cortex-m architecture
use stm32f4xx_hal as _; // STM32F4 series HAL crate

// Debugger
use defmt::*;
use defmt_rtt as _;     // Global logger
use panic_probe as _;   // Panic handler with defmt support


// MAIN
#[allow(clippy::empty_loop)] 
#[entry] 
fn main() -&gt; ! {
    info!("Use cargo embed --example &lt;example name&gt;, to build examples!");

    loop {}
}</code></pre></pre>
<p>Don't forget to have you STM32F4 connected! A terminal should open and look like this:
<img src="examples/gpio/../../images/hello_world_terminal.png" alt="Hello World Terminal" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blinky"><a class="header" href="#blinky">Blinky</a></h1>
<p>Blinky will be our first attempt at using the STM32F4 HAL crate. We use this crate to access the peripherals of the STM32, safely wrapped in rust.</p>
<p>From the STM32F4 HAL we import the Peripheral Access Crate (PAC) and the preludes. The preludes import some generics and traits for embedded HAL that saves us some typing.
The PAC is how we access the peripherals of the microcontroller unit (MCU).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use stm32f4xx_hal::{
    pac::{self},
    prelude::*,
};
<span class="boring">}</span></code></pre></pre>
<h2 id="what-is-a-pac"><a class="header" href="#what-is-a-pac">What is a PAC?</a></h2>
<p>Peripheral Access Crate (PAC) is how we access the peripherals of the microcontroller unit (MCU).
To use the peripherals, we need to assign ownership of the device peripherals. This is required in rust to manage memory.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let dp = pac::Peripherals::take().unwrap();
<span class="boring">}</span></code></pre></pre>
<p>From the device peripherals, we split out the struct gpioa, which is the GPIO group A on the microcontroller. We can see in the datasheet that this group contains pins 0-15 (PA0-15).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let gpioa = dp.GPIOA.split();
<span class="boring">}</span></code></pre></pre>
<p>We can assign a single pin to a variable and configure it, in this case we want to configure it into a push/pull output, to either connect our LED to power or ground.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut LD1 = gpioa.pa5.into_push_pull_output();
<span class="boring">}</span></code></pre></pre>
<p>Now that we have configured PA5 into a push/pull output with the name LD1, which correspondes with the LD1 LED on the ST NucleoF401RE board. We probably want to do something with it right?
We can turn it off, with the following commands:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    LD1.set_low();
    LD1.set_high();
<span class="boring">}</span></code></pre></pre>
<p>We also want it to blink, we can use <code>cortex_m::asm::delay(8_000_000);</code>, this simply pauses the program for 8 000 000 million clock cycles, and since our clock runs at 8MHz, that equates to 1 second.<br />
By adding a conversion factor, we can use milliseconds instead, giving us a simple blinky program:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Clock-cycles to millisecond conversion factor
let ms: u32 = 8_000;
    loop {
        // Wait 500ms
        cortex_m::asm::delay(500 * ms);

        // Turn on LED LD1
        LD1.set_high();

        // Wait 500ms
        cortex_m::asm::delay(500 * ms);

        // Turn off LED LD1
        LD1.set_low();   
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<p>Here is a complete code example, it is the default example, and can be run with:</p>
<pre><code class="language-sh">$ cargo embed --example blinky
</code></pre>
<pre><pre class="playground"><code class="language-rust">// ========================== Embedded Rust Set-up ==========================
#![deny(unsafe_code)]
#![no_main]
#![no_std]


// Imports
use defmt::*;
use defmt_rtt as _; // Global logger
use panic_probe as _; // Panic handler with defmt support
use cortex_m_rt::entry;
use stm32f4xx_hal::{
    pac::{self},
    prelude::*,
};


#[allow(non_snake_case)]
#[allow(clippy::empty_loop)]
#[entry]
fn main() -&gt; ! {
    // ========================== Set-up ==========================
    // Take ownership of device peripherals and split out GPIO group A and B
    let dp = pac::Peripherals::take().unwrap();
    let gpioa = dp.GPIOA.split();

    // Configure pins
    let mut LD1 = gpioa.pa5.into_push_pull_output();
    LD1.set_low();

    // Calculate conversion factor from clock cycles to ms, assuming 8 MHz
    let ms: u32 = 8_000;


   // ========================== LOOP ==========================
    loop {
        // Wait 500ms
        cortex_m::asm::delay(500 * ms);

        // Turn on LED LD1
        LD1.set_high();

        // Wait 500ms
        cortex_m::asm::delay(500 * ms);

        // Turn off LED LD1
        LD1.set_low();

        
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="buten-controlled-light"><a class="header" href="#buten-controlled-light">Buten Controlled Light</a></h1>
<p>Being able to have some inputs would be nice right?
So lets try controlling the LED with the on-board button. Just like in the blinky example, we need to split out of peripherals. We also split out GPIO group C, since the on-board button B1, is connected to pin 13 in group C, PC13.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let dp = pac::Peripherals::take().unwrap();
    let gpioa = dp.GPIOA.split();
    let gpioc = dp.GPIOC.split();
<span class="boring">}</span></code></pre></pre>
<p>We then assign PC13 to B1. Notice here we don't need to declare B1 a mutable variable, since we only read data from it. (If we wanted to write to it, we had to make it mutable).<br />
We then check if B1 is true (high) using <code>.is_low()</code>, and set our LED LD1 high if it is.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let B1 = gpioc.pc13;

loop {
    // Check if button is pressed
    if B1.is_low() {
        LD1.set_high(); // Turn ON LED
    } else {
        LD1.set_low(); // Turn OFF LED
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example-2"><a class="header" href="#complete-example-2">Complete Example</a></h2>
<p>Here is a complete code example and can be run with:</p>
<pre><code class="language-sh">$ cargo embed --example buten
</code></pre>
<pre><pre class="playground"><code class="language-rust">// ========================== Embedded Rust Set-up ==========================
#![deny(unsafe_code)]
#![no_main]
#![no_std]


// Imports
use defmt_rtt as _; // Global logger
use panic_probe as _; // Panic handler with defmt support
use cortex_m_rt::entry;
use stm32f4xx_hal::{
    pac::{self},
    prelude::*,
};


#[allow(non_snake_case)]
#[allow(clippy::empty_loop)]
#[entry]
fn main() -&gt; ! {
    // ========================== Set-up ==========================
    // Take ownership of device peripherals and split out GPIO group A and B
    let dp = pac::Peripherals::take().unwrap();
    let gpioa = dp.GPIOA.split();
    let gpioc = dp.GPIOC.split();

    // Configure pins
    let mut LD1 = gpioa.pa5.into_push_pull_output();
    LD1.set_low();
    let B1 = gpioc.pc13;

   // ========================== LOOP ==========================
    loop {
        // Check if button is pressed
        if B1.is_low() {
            LD1.set_high(); // Turn ON LED
        } else {
            LD1.set_low(); // Turn OFF LED
        }
    }
}</code></pre></pre>
<p>(btw, buten is a inside joke, I am not illiterate)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dimming-a-led-using-pwm"><a class="header" href="#dimming-a-led-using-pwm">Dimming a LED using PWM</a></h1>
<p>Now lets try ourselvs at something a bit more advanced. A LED that is dimmed with the help of a button.
We will dim it using PWM, but before we can do this, we need to configure the clocks and timers, which in turn control our PWM.</p>
<p>We give ownership of the reset and clock control to <code>rcc</code>, from <code>dp</code>.<br />
Then configure(<code>.cfgr</code>) it from a high speed external(<code>use_hse()</code>) clock running at 8 MHz(<code>8.MHz()</code>) and lock the configuration(<code>.freeze()</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Configure clocks
    let rcc = dp.RCC.constrain();
    let clocks = rcc.cfgr.use_hse(8.MHz()).freeze();
<span class="boring">}</span></code></pre></pre>
<p>Now to the juicy part, we actually configure one of our timers (Timer 2, TIM2) for PWM.
To do this, we do this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Configure PWM
let (_, (LD1_pwm, ..)) = dp.TIM2.pwm_hz(2000.Hz(), &amp;clocks);
<span class="boring">}</span></code></pre></pre>
<p>So what is going on here?<br />
Here we take timer 2(<code>TIM2</code>) from the device peripheral handler(<code>dp</code>), and configure it for PWM with hertz as a input (<code>.pwm_hz()</code>). And set the PWM frequency to 2000 Hz (<code>.Hz()</code>), and use our on-board clock as a reference (<code>&amp;clocks</code>).<br />
Now why do we assign it to <code>(_, (LD1_pwm, ..))</code>?<br />
This is because it returns an array, where the first spot is the PWM controller, which we ignore with (<code>_</code>), then the second spot is all the PWM channels
<code>(LD1_pwm, ..))</code>. The first channel is assigned to <code>LD1_pwm</code>, while we ignore the rest with <code>, ..)</code>, it would be the same as putting <code>_</code> for all the other channels.
Can I do PWM now? No, have patience my child. We have our PWM channel, we now need to assign it to a suitable pin,
so we assign <code>LD1_pwm</code> to pin 5 in GPIO group A (<code>pa5</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut LD1_pwm = LD1_pwm.with(gpioa.pa5);
let max_duty = LD1_pwm.get_max_duty();
LD1_pwm.enable();
<span class="boring">}</span></code></pre></pre>
<p>We also use <code>.get_max_duty()</code> to get the maximum PWM value, and <code>.enable()</code> to enable the channel.</p>
<p>Finally, we can set the PWM duty cycle for PA5, we do this with <code>.set_duty()</code>, and give it a division of <code>max_duty</code>.<br />
In this case divided by 4 or 25% duty cycle.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>LD1_pwm.set_duty(max_duty / 4); // 25% duty for LED LD1. 
<span class="boring">}</span></code></pre></pre>
<p>Now lets make it even cooler. Lets have 10 levels (0-100%), controlled by a button!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Initialize counter variable
    let mut counter = 0;

    // Calculate conversion factor from clock cycles to ms, assuming 8 MHz
    let ms: u32 = 8_000;
    
   loop {
    if B1.is_low() {
        cortex_m::asm::delay(50 * ms); // debounce delay
        if B1.is_low() {
            counter = (counter + 1) % 11; // increment and roll over after 10 (0-10 total 11 states)

            // Wait until button released
            while B1.is_high() {}
        }
    }

    // Set PWM for LD1
    let duty = (max_duty * counter) / 10; // 10 steps (0%, 10%, ..., 100%)
    LD1_pwm.set_duty(duty);
}
<span class="boring">}</span></code></pre></pre>
<p>Here we initialize the counter and calculate the clock-cycle to ms factor.<br />
In the main loop we check if our button is pressed(<code>if B1.is_low()</code>), if it is, we wait for 50ms(<code>cortex_m::asm:delay(50*ms)</code>), then if it still is pressed, we increment the counter. The reason for the delay is a quick-and-dirty debounce of the button. To increment to counter from 0-10, we use this <code>counter = (counter + 1) % 11</code>. Then wait for the button to be unpressed (<code>while B1.is_high()</code>), so we don't increment more than once.</p>
<p>Outside the loop, we calculate the desired duty cycle from the counter and apply it to our LED, LD1.</p>
<h2 id="complete-example-3"><a class="header" href="#complete-example-3">Complete Example</a></h2>
<p>Here is a complete code example and can be run with:</p>
<pre><code class="language-sh">$ cargo embed --example pwm_dimmer
</code></pre>
<pre><pre class="playground"><code class="language-rust">// ========================== Embedded Rust Set-up ==========================
#![deny(unsafe_code)]
#![no_main]
#![no_std]


// Imports
use defmt_rtt as _; // Global logger
use panic_probe as _; // Panic handler with defmt support
use cortex_m_rt::entry;
use stm32f4xx_hal::{
    pac::{self},
    prelude::*,
};


#[allow(non_snake_case)]
#[allow(clippy::empty_loop)]
#[entry]
fn main() -&gt; ! {
    // ========================== Set-up ==========================
    // Take ownership of device peripherals and split out GPIO group A and B
    let dp = pac::Peripherals::take().unwrap();
    let gpioa = dp.GPIOA.split();
    let gpioc = dp.GPIOC.split();

    // Configure clocks
    let rcc = dp.RCC.constrain();
    let clocks = rcc.cfgr.use_hse(8.MHz()).freeze();

    // Configure pins
    let B1 = gpioc.pc13;

    // Configure PWM
    let (_, (LD1_pwm, ..)) = dp.TIM2.pwm_hz(2000.Hz(), &amp;clocks);
    let mut LD1_pwm = LD1_pwm.with(gpioa.pa5);
    let max_duty = LD1_pwm.get_max_duty();
    LD1_pwm.enable();

    // Initialize counter variable
    let mut counter = 0;

    // Calculate conversion factor from clock cycles to ms, assuming 8 MHz
    let ms: u32 = 8_000;
    

   // ========================== LOOP ==========================
   loop {
    if B1.is_low() {
        cortex_m::asm::delay(50 * ms); // debounce delay
        if B1.is_low() {
            counter = (counter + 1) % 11; // increment and roll over after 10 (0-10 total 11 states)

            // Wait until button released
            while B1.is_high() {}
        }
    }

    // Set PWM for LD1
    let duty = (max_duty * counter) / 10; // 10 steps (0%, 10%, ..., 100%)
    LD1_pwm.set_duty(duty);
}
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dimming-a-led-using-a-potentiometer"><a class="header" href="#dimming-a-led-using-a-potentiometer">Dimming a LED using a potentiometer</a></h1>
<p>Lets try controlling the brightness of a LED using a potentiometer. To do things we need to measure the analog voltage from a potentiometer.<br />
To do this, we need to import the adc peripheral from the HAL library:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use stm32f4xx_hal::{
    pac::{self},
    adc::{config::AdcConfig, config::SampleTime, Adc},
    prelude::*,
};
<span class="boring">}</span></code></pre></pre>
<p>Then we configure our pin PA0 into a analog pin, then configure the adc connected to it (ADC1), as ADC.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Configure ADC
let dimmer = gpioa.pa0.into_analog();
let mut adc = Adc::adc1(dp.ADC1, true, AdcConfig::default());
<span class="boring">}</span></code></pre></pre>
<p>Now, we can read the raw analog value using adc.convert.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Read Dimmer 
let duty = adc.convert(&amp;dimmer, SampleTime::Cycles_480);
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example-4"><a class="header" href="#complete-example-4">Complete Example</a></h2>
<p>Here is a complete code example and can be run with:</p>
<pre><code class="language-sh">$ cargo embed --example potmeter_dimmer
</code></pre>
<pre><pre class="playground"><code class="language-rust">// ========================== Embedded Rust Set-up ==========================
#![deny(unsafe_code)]
#![no_main]
#![no_std]


// Imports
use defmt::*;
use defmt_rtt as _; // Global logger
use panic_probe as _; // Panic handler with defmt support
use cortex_m::asm;
use cortex_m_rt::entry;
use stm32f4xx_hal::{
    pac::{self},
    adc::{config::AdcConfig, config::SampleTime, Adc},
    prelude::*,
};


#[allow(non_snake_case)]
#[allow(clippy::empty_loop)]
#[entry]
fn main() -&gt; ! {
    // ========================== Set-up ==========================
    // Take ownership of device peripherals and split out GPIO group A and B
    let dp = pac::Peripherals::take().unwrap();
    let gpioa = dp.GPIOA.split();

    // Configure clocks
    let rcc = dp.RCC.constrain();
    let clocks = rcc.cfgr.use_hse(8.MHz()).freeze();

    // Configure ADC
    let dimmer = gpioa.pa0.into_analog();
    let mut adc = Adc::adc1(dp.ADC1, true, AdcConfig::default());

    // Configure PWM
    let (_, (LD1_pwm, ..)) = dp.TIM2.pwm_hz(2000.Hz(), &amp;clocks);
    let mut LD1_pwm = LD1_pwm.with(gpioa.pa5);
    LD1_pwm.enable();

    // Calculate conversion factor from clock cycles to ms, assuming 8 MHz
    let ms: u32 = 8_000;


   // ========================== LOOP ==========================
    loop {
        // Read Dimmer 
        let duty = adc.convert(&amp;dimmer, SampleTime::Cycles_480);

        // Set LED duty
        LD1_pwm.set_duty(duty);  // Turn OFF LED

        // Print Duty
        info!("Dimmer = {}", duty);

        // Delay until next cycle
        asm::delay(100 * ms); 

    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sending-and-receiving-messages-to-your-mcu"><a class="header" href="#sending-and-receiving-messages-to-your-mcu">Sending and receiving messages to your MCU</a></h1>
<p>This chapter covers UART, and some common applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="read-and-write-uart-on-your-pc-using-putty"><a class="header" href="#read-and-write-uart-on-your-pc-using-putty">Read and write UART on your PC using Putty</a></h1>
<p>To read or write UART messages, we can use Putty. We first need to figure out which COM port our MCU is on, we can find this in the device manager under "COM &amp; LPT":</p>
<figure>
  <img src="examples/uart/../../images/device_manager.png" alt="Description" width="600">
  <figcaption>Figure 2 - Device manager showing COM ports.</figcaption>
</figure>
<p>Next, we need to configure our serial connection in Putty, under Connection -&gt; Serial:</p>
<figure>
  <img src="examples/uart/../../images/putty_serial_setup.png" alt="Description" width="600">
  <figcaption>Figure 2 - Putty serial settings.</figcaption>
</figure>
<ul>
<li>Set "Serial line to connect to" to the COM port for your MCU, in my case COM6.</li>
<li>Set "Speed" (baudrate) to 115200, the same we configured in our code.</li>
<li>Set "Flow Control" to "None".</li>
</ul>
<p>Then, go to "Session" and select serial and press open.</p>
<figure>
  <img src="examples/uart/../../images/putty_serial_session.png" alt="Description" width="600">
  <figcaption>Figure 2 - Starting a Putty serial session.</figcaption>
</figure>
<p>Assuming you have already flashed your MCU, you should be seeing these messages!</p>
<figure>
  <img src="examples/uart/../../images/putty_serial_messages.png" alt="Description" width="600">
  <figcaption>Figure 2 - Putty serial settings.</figcaption>
</figure>
<p>To send messages, you can write in the terminal. If you want to see your writing, the MCU has to either echo the your letters, or you can enable "Force Echo" on putty, by going to Terminal -&gt; Local echo -&gt; "Force on":</p>
<figure>
  <img src="examples/uart/../../images/putty_echo.png" alt="Description" width="600">
  <figcaption>Figure 2 - Enable force echo on Putty.</figcaption>
</figure><div style="break-before: page; page-break-before: always;"></div><h1 id="sending-messages-from-the-mcu"><a class="header" href="#sending-messages-from-the-mcu">Sending messages from the MCU</a></h1>
<p>Now we will have a look at UART communication. The bread-and-butter communication between a PC and MCU.</p>
<p>To use UART on the STM32F4, we need to include the <code>serial</code> module:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use stm32f4xx_hal::{
    pac,
    prelude::*,
    serial::{config::Config, Serial},
};
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>config::Config</code> - A struct containing the UART configuration.</li>
<li><code>Serial</code> - A struct used to set-up UART and pin configuration.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::fmt::Write;
<span class="boring">}</span></code></pre></pre>
<p>We include <code>core::fmt</code> to write formatted text over UART.</p>
<p>Then, we configure our GPIO pins for UART.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Configure rx and tx pins
let tx = gpioa.pa2.into_alternate();
let rx = gpioa.pa3.into_alternate();
<span class="boring">}</span></code></pre></pre>
<p>Here we set PA2 as TX pin and PA3 as RX pin.</p>
<p>Then we create a a object for the serial communication, using USART2, our pins, serial configuration and clocks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Configure serial with default settings and baud rate of 115200. 
let serial_config = Config::default().baudrate(115_200.bps());
let mut serial = Serial::new(dp.USART2, (tx, rx), serial_config, &amp;clocks).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>Now we can finally send a message!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>writeln!(serial, "hello world!\r").ok();
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example-5"><a class="header" href="#complete-example-5">Complete Example</a></h2>
<p>Here is a complete code example, it is the default example, and can be run with:</p>
<pre><code class="language-sh">$ cargo embed --example uart_hello_world
</code></pre>
<pre><pre class="playground"><code class="language-rust">// Compiler directives
#![no_std]
#![no_main]

// Libraries
// Generic
use cortex_m_rt::entry;
use defmt_rtt as _;
use panic_probe as _;

// UART Specific
use core::fmt::Write; // Used for formatted text over UART. 
use stm32f4xx_hal::{
    pac,
    prelude::*,
    serial::{
        config::Config, // Struct for storing the UART configuration.
        Serial // Struct used to initialize UART and pin configuration. 
    },
};



#[entry]
fn main() -&gt; ! {
    // Take ownership of peripherals and configure clocks
    let dp = pac::Peripherals::take().unwrap();
    let rcc = dp.RCC.constrain();
    let clocks = rcc.cfgr.freeze();

    // Split out GPIO group A and configure rx and tx pins.
    let gpioa = dp.GPIOA.split();
    let tx = gpioa.pa2.into_alternate();
    let rx = gpioa.pa3.into_alternate();

    // Configure UART communication for 115200 baud rate on USART2. 
    let serial_config = Config::default().baudrate(115_200.bps());
    let mut serial = Serial::new(dp.USART2, (tx, rx), serial_config, &amp;clocks).unwrap();

    // Clock cycle to ms conversion factor
    let ms: u32 = 8_000;


    loop {
        // Send UART message
        writeln!(serial, "hello world!\r").ok();

        // Wait for 1000 ms
        cortex_m::asm::delay(1000 * ms); // 1 second delay
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sending-and-receiving-messages-to-your-mcu-1"><a class="header" href="#sending-and-receiving-messages-to-your-mcu-1">Sending and receiving messages to your MCU</a></h1>
<p>You might be interested in sending UART messages to your MCU, in this chapter we will cover this and parsing them.
We will assume that you have familiarized yourself with the previous example "Sending messages from the MCU".</p>
<p>We include <code>core::fmt</code> and <code>heapless::String</code>. <code>core::fmt</code> is used to write formatted text over UART. While <code>heapless::String</code> gives us data structures without dynamic memory allocation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::fmt::Write;
use heapless::String; // fixed-capacity string
<span class="boring">}</span></code></pre></pre>
<p>The major difference in this case, is that we want to read AND write messages this time. To do this, we need to split our serial object in two:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (mut tx, mut rx) = serial.split();
<span class="boring">}</span></code></pre></pre>
<p>This way, we can handle sending and receiving messages differently. In addition, we need to store our messages in order to parse them:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut buffer: String&lt;64&gt; = String::new();
<span class="boring">}</span></code></pre></pre>
<p>Now here is the juicy part, we want to actually read, store and parse the UART message:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop { // Wait for a full line of input
            if let Ok(byte) = rx.read() { // If a UART byte is received:
                let c = byte as char;   // Convert byte to char.
                if c == '\r' || c == '\n' {   // If it is a carrige return or line break, end loop.
                    break;
                } else {
                    buffer.push(c).ok();     // Else, add char to buffer.
                }
            }
        }
<span class="boring">}</span></code></pre></pre>
<p>A loop that continuously reads characters from the UART receiver (rx).If it reads a byte from the UART input, it returns nb::Result, so Ok(byte) means a new byte is available.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Ok(byte) = rx.read() {
            ...
}
<span class="boring">}</span></code></pre></pre>
<p>If a byte is read, its converted from a u8 to a char.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let c = byte as char;
<span class="boring">}</span></code></pre></pre>
<p>If the character is a newline (\n) or carriage return (\r), we assume the user has finished typing, so we break the loop.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if c == '\r' || c == '\n' {
            break;
        }
<span class="boring">}</span></code></pre></pre>
<p>Else, we store it to the buffer, for later parsing.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>else {
        buffer.push(c).ok();
    }
<span class="boring">}</span></code></pre></pre>
<p>Next, we want to greet the user after they have connected, once, so we add a check if this is the first loop.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        if first_loop {
            writeln!(tx, "\r\nWelcome to the STM32 UART Menu! \r\n").ok();
            first_loop = false;
            }
<span class="boring">}</span></code></pre></pre>
<p>Now we need to create our menu, to keep it clean, I've kept it as a separate function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_menu&lt;W: Write&gt;(tx: &amp;mut W) {
    writeln!(tx, "== Menu == \r\n").ok();
    writeln!(tx, "1. Turn LED ON \r\n").ok();
    writeln!(tx, "2. Turn LED OFF \r\n").ok();
    writeln!(tx, "3. Print STATUS \r\n").ok();
    writeln!(tx, "4. Reset \r\n").ok();
}
<span class="boring">}</span></code></pre></pre>
<p>The menu takes in our transmitter object <code>tx</code>, and then prints out our menu. Nice and simple. Next we want to respond to what the user actually sent:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print_menu(&amp;mut tx);
match buffer.trim() {
    "1" =&gt; writeln!(tx, "You selected option 1: LED ON"),
    "2" =&gt; writeln!(tx, "You selected option 2: LED OFF"),
    "3" =&gt; writeln!(tx, "You selected option 3: STATUS OK"),
    "4" =&gt; writeln!(tx, "You selected option 4: Resetting..."),
    _   =&gt; writeln!(tx, "ERROR! Invalid command: {}", buffer),
}.ok();
<span class="boring">}</span></code></pre></pre>
<p>Here we first display our menu, then we use <code>match</code>, to match the user's response with our look up table, and write back.</p>
<p>Finally, we clear the buffer, and give ourself some extra headroom for the next response:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>buffer.clear();

writeln!(tx, "\r\n\n\n").ok();
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example-6"><a class="header" href="#complete-example-6">Complete Example</a></h2>
<p>Here is a complete code example, it is the default example, and can be run with:</p>
<pre><code class="language-sh">$ cargo embed --example uart_cli
</code></pre>
<p>To interact, connect with Putty, and press enter once to get a response.</p>
<pre><pre class="playground"><code class="language-rust">// Compiler directives
#![no_std]
#![no_main]

// Libraries
// Generic
use cortex_m_rt::entry;
use defmt_rtt as _;
use panic_probe as _;

// UART Specific
use core::fmt::Write; // Used for formatted text over UART. 
use heapless::String; // fixed-capacity string
use stm32f4xx_hal::{
    pac,
    prelude::*,
    serial::{
        config::Config, // Struct for storing the UART configuration.
        Serial // Struct used to initialize UART and pin configuration. 
    },
};



#[entry]
fn main() -&gt; ! {
    // Take ownership of peripherals and configure clocks
    let dp = pac::Peripherals::take().unwrap();
    let rcc = dp.RCC.constrain();
    let clocks = rcc.cfgr.freeze();

    // Split out GPIO group A and configure rx and tx pins.
    let gpioa = dp.GPIOA.split();
    let tx = gpioa.pa2.into_alternate();
    let rx = gpioa.pa3.into_alternate();

    // Configure UART communication for 115200 baud rate on USART2. 
    let serial_config = Config::default().baudrate(115_200.bps());
    let mut serial = Serial::new(dp.USART2, (tx, rx), serial_config, &amp;clocks).unwrap();

    // Split serial object into receiver and transmitter.
    let (mut tx, mut rx) = serial.split();

    // Message buffer
    let mut buffer: String&lt;64&gt; = String::new();

    // First loop check
    let mut first_loop: bool = true;



    loop {
        loop { // Wait for a full line of input
            if let Ok(byte) = rx.read() { // If a UART byte is received:
                let c = byte as char;   // Convert byte to char.
                if c == '\r' || c == '\n' {   // If it is a carrige return or line break, end loop.
                    break;
                } else {
                    buffer.push(c).ok();     // Else, add char to buffer.
                }
            }
        }

        // Run CLI application
        // Greet user on first loop.
        if first_loop {
            writeln!(tx, "\r\nWelcome to the STM32 UART Menu! \r\n").ok();
            first_loop = false;
            }

        // Display Menu
        print_menu(&amp;mut tx); // Print menu

        // Respond to user
        match buffer.trim() {
            "1" =&gt; writeln!(tx, "You selected option 1: LED ON"),
            "2" =&gt; writeln!(tx, "You selected option 2: LED OFF"),
            "3" =&gt; writeln!(tx, "You selected option 3: STATUS OK"),
            "4" =&gt; writeln!(tx, "You selected option 4: Resetting..."),
            _   =&gt; writeln!(tx, "ERROR! Invalid command: {}", buffer),
        }.ok();

        // Clear buffer
        buffer.clear();

        // Clear space for next response
        writeln!(tx, "\r\n\n\n").ok();
    }
}


// Functions
fn print_menu&lt;W: Write&gt;(tx: &amp;mut W) {
    writeln!(tx, "== Menu == \r\n").ok();
    writeln!(tx, "1. Turn LED ON \r\n").ok();
    writeln!(tx, "2. Turn LED OFF \r\n").ok();
    writeln!(tx, "3. Print STATUS \r\n").ok();
    writeln!(tx, "4. Reset \r\n").ok();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-i2c"><a class="header" href="#using-i2c">Using I2C</a></h1>
<p>Plain and simple, I2C is useful. This is not a guide on how I2C works, just show to read and write messages.</p>
<p>To use i2C, we need to import the module <code>I2c</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use stm32f4xx_hal::{
    pac::{self},
    prelude::*,
    i2c::I2c,
};
<span class="boring">}</span></code></pre></pre>
<p>Configuring up I2C is quite simple. We simply need to find two valid i2C pins, like <code>PB9</code> and <code>PB8</code>, which is connected to the peripheral <code>I2C1</code>. We configure this pins into alternate mode, with a open drain, letting our i2C peripheral set their mode:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let scl = gpiob.pb8.into_alternate().set_open_drain();
    let sda = gpiob.pb9.into_alternate().set_open_drain();
    let mut i2c = I2c::new(dp.I2C1, (scl, sda), 100.kHz(), &amp;clocks);
<span class="boring">}</span></code></pre></pre>
<p>To read from a sensor, we can use <code>.write_read</code>, which sends a message to the address specified (<code>AS5600_ADDR</code>), and reads the register <code>AS5600_RAW_ANGLE_REG</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>i2c.write_read(AS5600_ADDR, &amp;[AS5600_RAW_ANGLE_REG], &amp;mut buf).is_ok()
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example-7"><a class="header" href="#complete-example-7">Complete Example</a></h2>
<p>Here is a complete code example, it is the default example, and can be run with:</p>
<pre><code class="language-sh">$ cargo embed --example i2c_as5600
</code></pre>
<pre><pre class="playground"><code class="language-rust">// ========================== Embedded Rust Set-up ==========================
#![deny(unsafe_code)]
#![no_main]
#![no_std]


// Imports
use defmt::*;
use defmt_rtt as _; // Global logger
use panic_probe as _; // Panic handler with defmt support
use cortex_m_rt::entry;
use stm32f4xx_hal::{
    pac::{self},
    prelude::*,
    i2c::I2c,
};


#[allow(non_snake_case)]
#[allow(clippy::empty_loop)]
#[entry]
fn main() -&gt; ! {
    // ========================== Set-up ==========================
    // Take ownership of device peripherals and split out GPIO group A and B
    let dp = pac::Peripherals::take().unwrap();
    let gpiob = dp.GPIOB.split();

    // Configure clocks
    let rcc = dp.RCC.constrain();
    let clocks = rcc.cfgr.freeze();

   // ========================== Constants ==========================
    const AS5600_ADDR: u8 = 0x36;       // 7-bit I2C address
    const AS5600_RAW_ANGLE_REG: u8 = 0x0C; // MSB of raw angle
    let ms: u32 = 8_000; // clock cycles to millisecond conversion.
    let raw2deg: f32 = 360.0 / 4096.0;
    let mut ang_rotor_deg: f32 = 0.0;
    let mut ang_rotor_raw: u16 = 0;

    // ========================= I2C Setup ==========================
    let scl = gpiob.pb8.into_alternate().set_open_drain();
    let sda = gpiob.pb9.into_alternate().set_open_drain();
    let mut i2c = I2c::new(dp.I2C1, (scl, sda), 100.kHz(), &amp;clocks);


    // ========================== Main Loop ==========================
    loop {
        // Read Motor Position
        let mut buf = [0u8; 2];
        if i2c.write_read(AS5600_ADDR, &amp;[AS5600_RAW_ANGLE_REG], &amp;mut buf).is_ok() {
            ang_rotor_raw = ((buf[0] as u16) &lt;&lt; 8) | (buf[1] as u16);
        }
        else {
            warn!("I2C read failed");
        }

        // Convert to degrees
        ang_rotor_deg = (ang_rotor_raw as f32) * raw2deg;
        
        // Send Position over defmt
        info!("Rotor position = {}", ang_rotor_deg);

        // Wait 500ms
        cortex_m::asm::delay(200 * ms);
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rtic"><a class="header" href="#rtic">RTIC</a></h1>
<p>So far, we have only used blocking logic. Meaning, we only do one thing at a time. So for example when we blink our LED, we rush over to the light switch and flip it, then religiously wait for one second. Meaning we do nothing while we wait, which seems like a waste doesn't it?</p>
<p>Well, RTIC is here to save the day! Now we can boost our productivity by 1000^10%! Think about all the things you could do while waiting, like cleaning your room <em>side-eye</em>.</p>
<p>To use RTIC, we will need a couple more crates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rtt_target::{rprintln, rtt_init_print};
use panic_rtt_target as _;
use rtic::app;
use rtic_monotonics::systick::prelude::*;
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>use rtt_target::{rprintln, rtt_init_print};</code> - Imports the Real-Time Transfer (RTT) interface.
<ul>
<li><code>rtt_init_print</code> - Print line macro that works of RTT.</li>
<li><code>rprintln</code> - Used to initialize RTT.</li>
</ul>
</li>
<li><code>use panic_rtt_target as _;</code> - Imports panic handler for RTT.</li>
<li><code>use rtic::app;;</code> - Imports the RTIC app.</li>
<li><code>use rtic_monotonics::systick::prelude::*;</code> - Imports monotonic timer.</li>
</ul>
<p>What is a monotonic timer? I am glad you asked! It it our reference used to schedule tasks and set delays. In the example below, we make a timer running at 1000 Hz, which equals about 1 ms resolution. Allowing us to schedule in milliseconds.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>systick_monotonic!(Mono, 1000); // 1000 Hz
<span class="boring">}</span></code></pre></pre>
<p>Next, we will have a look at the structure of a RTIC app:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[app(
    device = stm32f4xx_hal::pac,  // This device uses the stm32f4xx_hal Peripheral Access Crate (PAC).
    peripherals = true,           // Auto-initializes the Peripherals struct (dp).
    dispatchers = [SPI1],         // Unused interrupts that RTIC can use internally for software tasks, in this case SPI1. 
)]
mod app {
    // Import everything (*) from the parent module (rtic_blinky.rs)
    use super::*;

    // Resources
    #[shared] // Shared between different tasks
    struct Shared {}

    #[local] // Task local data only
    struct Local {}


    #[init] // Start-up function that initializes the program.
    fn init(cx: init::Context) -&gt; (Shared, Local) {
        (...)
        (Shared {}, Local {})
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The first part of our structure has the <code>#[app()]</code>. It contains the configuration for our RTIC app, like which device we are using (STM32F4), if we want to auto-initialize our peripherals (<code>peripherals</code>) and which interrupts (<code>SPI1</code>) are free for the app to use (<code>dispatchers</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[app(
    device = stm32f4xx_hal::pac,  
    peripherals = true,           
    dispatchers = [SPI1],         
)]
<span class="boring">}</span></code></pre></pre>
<p>Next, we have the app body.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod app {
    use super::*;

    #[shared]
    struct Shared {}

    #[local]
    struct Local {}

    #[init] 
    fn init(cx: init::Context) -&gt; (Shared, Local) {
        (...)
        (Shared {}, Local {})
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The first line <code>use super::*;</code>, simply brings all (<code>*</code>) the imports from the module (<code>your_code.rs</code>) into the app.</p>
<p>Next, we have the resources avaiable in the app, think variables, data structures etc.</p>
<ul>
<li>The shared struct (<code>struct Shared {}</code>), contains resources shared between tasks, like sensor readings.</li>
<li>The local struct (<code>struct Local {}</code>), contains local data only used within a task, and is NOT shared between structs.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[shared]
struct Shared {}

#[local]
struct Local {}
<span class="boring">}</span></code></pre></pre>
<p>Lastly we have the <code>init</code> function. This functions initializes our program and kicks it off. We need it since we don't have a main loop anymore.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[init] 
fn init(cx: init::Context) -&gt; (Shared, Local) {
    (...)
    (Shared {}, Local {})
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>init</code> function takes our <code>Local</code> and <code>Shared</code> struct, and puts it into the context struct <code>cx</code>.<br />
It also allows us to initialize our resources:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(Shared {}, Local {})
<span class="boring">}</span></code></pre></pre>
<p>In addition, we have tasks <code>#[task()]</code>. We use these to perform actions, like blinking a LED, reading a UART message or setting the duty cycle for PWM.
A task may look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> #[task(local = [led, state])] // This task uses the local resources "led" and "state".
    async fn blink(cx: blink::Context) { // Use context cx to access local and shared resources.
        loop {
            rprintln!("blink");
            // Access local resources from context (cx.local)
            if *cx.local.state {         // If LED is on.
                cx.local.led.set_high();
                *cx.local.state = false;
            } else {                     // If LED is off
                cx.local.led.set_low();
                *cx.local.state = true;
            }
            // At the end of the task, wait 1000 ms (none-blocking).
            Mono::delay(1000.millis()).await;
        }
    }
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>#[task(local = [led, state])]</code> - Here the task uses the <code>led</code> and <code>state</code> resources from the local resources struct <code>Local</code>.</li>
<li><code>#async fn blink(cx: blink::Context)</code> - We declare it as a async function (always required in RTIC V2), and access the resources and peripherals through context(<code>cx</code>).</li>
</ul>
<p>The loop operates similarlly as we have done before, but we now access the LED and its state through the <code>cx.local</code> struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    rprintln!("blink");
    // Access local resources from context (cx.local)
    if *cx.local.state {         // If LED is on.
        cx.local.led.set_high();
        *cx.local.state = false;
        ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Finally at the end, we make use of our monotonic timer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Mono::delay(1000.millis()).await;
<span class="boring">}</span></code></pre></pre>
<p>As opposed to our old delay, this delay will not block the CPU, allowing it to do other tasks in the background while the <code>blink</code> task is waiting.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blinking-a-led"><a class="header" href="#blinking-a-led">Blinking a LED</a></h1>
<p>Now, how do we blink a LED using RTIC?</p>
<p>As always, we need our imports, and to set up our timer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rtt_target::{rprintln, rtt_init_print};
use panic_rtt_target as _;
use rtic::app;
use rtic_monotonics::systick::prelude::*;
use stm32f4xx_hal::{
    pac::{self},
    prelude::*,
    gpio::{Output, PushPull, PA5},
};

// Set monotonic time to 1000 Hz, 1 ms resolution.
systick_monotonic!(Mono, 1000);
<span class="boring">}</span></code></pre></pre>
<p>Then we start on our app:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[app(
    device = stm32f4xx_hal::pac,  // This device uses the stm32f4xx_hal Peripheral Access Crate (PAC).
    peripherals = true,           // Auto-initializes the Peripherals struct (dp).
    dispatchers = [SPI1],         // Unused interrupts that RTIC can use internally for software tasks. 
)]
mod app {
    // Import everything (*) from the parent module (rtic_blinky.rs)
    use super::*;

    // Resources
    #[shared] // Shared between different tasks
    struct Shared {}

    #[local] // Task local data only
    struct Local {
        led: PA5&lt;Output&lt;PushPull&gt;&gt;, // LED pin
        state: bool,                // LED state (ON/OFF)
    }


    #[init] // Start-up function that initializes the program.
    fn init(cx: init::Context) -&gt; (Shared, Local) {
        // Assign context device peripherals to dp.
        let dp = cx.device;

        // Initialize the systick interrupt &amp; obtain the token to prove that we did
        Mono::start(cx.core.SYST, 8_000_000); // default STM32F401 clock-rate is 8MHz

        // Report that the program successfully started.
        rtt_init_print!();
        rprintln!("init");

        // Setup LED
        let gpioa = dp.GPIOA.split();
        let mut led = gpioa.pa5.into_push_pull_output();
        led.set_low();

        // Schedule the blinking task
        blink::spawn().ok();

        // Initialize resources
        (Shared {}, Local { led, state: false })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We configure our app, telling it which PAC to use:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[app(
    device = stm32f4xx_hal::pac,  
    peripherals = true,           
    dispatchers = [SPI1],         
)]
<span class="boring">}</span></code></pre></pre>
<p>You might have noticed that we added an extra import from our HAL:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>gpio::{Output, PushPull, PA5},
<span class="boring">}</span></code></pre></pre>
<p>We need this when we are defining our resources:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[shared]
struct Shared {}

#[local]
struct Local {
    led: PA5&lt;Output&lt;PushPull&gt;&gt;, // LED pin
    state: bool,                // LED state (ON/OFF)
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, we use <code>output</code>, <code>PushPull</code> and <code>PA5</code> to define our LED pin and its state.</p>
<p>Next, we need to define our init function, we start by naming our device peripherals dp:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[init] // Start-up function that initializes the program.
    fn init(cx: init::Context) -&gt; (Shared, Local) {
        // Assign context device peripherals to dp.
        let dp = cx.device;
    }
<span class="boring">}</span></code></pre></pre>
<p>Next we start our timer, synchronizing it to the system clock.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Mono::start(cx.core.SYST, 8_000_000); // default STM32F401 clock-rate is 8MHz
<span class="boring">}</span></code></pre></pre>
<p>To make debugging easier, we initialize RTT, and print "init" to tell us that we initialized successfully.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rtt_init_print!();
rprintln!("init");
<span class="boring">}</span></code></pre></pre>
<p>We then set-up our LED pin, pretty similar to the blinky example right?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let gpioa = dp.GPIOA.split();
let mut led = gpioa.pa5.into_push_pull_output();
led.set_low();
<span class="boring">}</span></code></pre></pre>
<p>We spawn our blinker task (we will get to it!):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>blink::spawn().ok();
<span class="boring">}</span></code></pre></pre>
<p>And finally we set the initial state of our resources:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(
    Shared {}, 
    Local {
        led, 
        state: false 
        })
<span class="boring">}</span></code></pre></pre>
<p>Now, what about that blinker?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[task(local = [led, state])] // This task uses the local resources "led" and "state".
    async fn blink(cx: blink::Context) { // Use context cx to access local and shared resources.
        loop {
            rprintln!("blink");
            // Access local resources from context (cx.local)
            if *cx.local.state {         // If LED is on.
                cx.local.led.set_high();
                *cx.local.state = false;
            } else {                     // If LED is off
                cx.local.led.set_low();
                *cx.local.state = true;
            }
            // At the end of the task, wait 1000 ms (none-blocking).
            Mono::delay(1000.millis()).await;
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>We define our task using local resources, <code>led</code> and <code>state</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[task(local = [led, state])] 
<span class="boring">}</span></code></pre></pre>
<p>We name our function and tell it to use context <code>cx</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    async fn blink(cx: blink::Context) {
        (...)
    }
<span class="boring">}</span></code></pre></pre>
<p>We implement our logic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
            rprintln!("blink");
            // Access local resources from context (cx.local)
            if *cx.local.state {         // If LED is on.
                cx.local.led.set_high();
                *cx.local.state = false;
            } else {                     // If LED is off
                cx.local.led.set_low();
                *cx.local.state = true;
            }
            // At the end of the task, wait 1000 ms (none-blocking).
            Mono::delay(1000.millis()).await;
        }
<span class="boring">}</span></code></pre></pre>
<p>Notice at the end that we use a new type of delay: <code>Mono::delay(1000.millis()).await;</code>. What this delay does, is to schedule a new blink task in 1000ms, in the mean time it waits (<code>.await</code>), leaving the CPU free to perform other tasks.
And that's it! Bobs your uncle.</p>
<h2 id="complete-example-8"><a class="header" href="#complete-example-8">Complete Example</a></h2>
<p>Here is a complete code example, it is the default example, and can be run with:</p>
<pre><code class="language-sh">$ cargo embed --example rtic_blinky
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ####  SET-UP  ####
// Compiler directives
#![deny(unsafe_code)]
#![no_main]
#![no_std]


// Imports
// Debugger output for RTT
use rtt_target::{rprintln, rtt_init_print};

// Panic handler for RTT
use panic_rtt_target as _;

// RTIC
use rtic::app;
use rtic_monotonics::systick::prelude::*;

// STM32F4 HAL
use stm32f4xx_hal::{
    pac::{self},
    prelude::*,
    gpio::{Output, PushPull, PA5},
};


// Set monotonic time to 1000 Hz, 1 ms resolution.
systick_monotonic!(Mono, 1000);




#[app(
    device = stm32f4xx_hal::pac,  // This device uses the stm32f4xx_hal Peripheral Access Crate (PAC).
    peripherals = true,           // Auto-initializes the Peripherals struct (dp).
    dispatchers = [SPI1],         // Unused interrupts that RTIC can use internally for software tasks. 
)]
mod app {
    // Import everything (*) from the parent module (rtic_blinky.rs)
    use super::*;

    // Resources
    #[shared] // Shared between different tasks
    struct Shared {}

    #[local] // Task local data only
    struct Local {
        led: PA5&lt;Output&lt;PushPull&gt;&gt;, // LED pin
        state: bool,                // LED state (ON/OFF)
    }


    #[init] // Start-up function that initializes the program.
    fn init(cx: init::Context) -&gt; (Shared, Local) {
        // Assign context device peripherals to dp.
        let dp = cx.device;

        // Initialize the systick interrupt &amp; obtain the token to prove that we did
        Mono::start(cx.core.SYST, 8_000_000); // default STM32F401 clock-rate is 8MHz

        // Report that the program successfully started.
        rtt_init_print!();
        rprintln!("init");

        // Setup LED
        let gpioa = dp.GPIOA.split();
        let mut led = gpioa.pa5.into_push_pull_output();
        led.set_low();

        // Schedule the blinking task
        blink::spawn().ok();

        // Initialize resources
        (Shared {}, Local { led, state: false })
    }



    // ####  TASKS  ####
    #[task(local = [led, state])] // This task uses the local resources "led" and "state".
    async fn blink(cx: blink::Context) { // Use context cx to access local and shared resources.
        loop {
            rprintln!("blink");
            // Access local resources from context (cx.local)
            if *cx.local.state {         // If LED is on.
                cx.local.led.set_high();
                *cx.local.state = false;
            } else {                     // If LED is off
                cx.local.led.set_low();
                *cx.local.state = true;
            }
            // At the end of the task, wait 1000 ms (none-blocking).
            Mono::delay(1000.millis()).await;
        }
    }
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
