<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Embedded Rust on the STM32F4 for dummies</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Embedded Rust on the STM32F4 for dummies</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Oh lordy</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set-up"><a class="header" href="#set-up">Set-up</a></h1>
<p>Have mercy</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blinky"><a class="header" href="#blinky">Blinky</a></h1>
<p>Blinky will be our first attempt at using the STM32F4 HAL crate. We use this crate to access the peripherals of the STM32, safely wrapped in rust.</p>
<p>From the STM32F4 HAL we import the Peripheral Access Crate (PAC) and the preludes. The preludes import some generics and traits for embedded HAL that saves us some typing.
The PAC is how we access the peripherals of the microcontroller unit (MCU).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use stm32f4xx_hal::{
    pac::{self},
    prelude::*,
};
<span class="boring">}</span></code></pre></pre>
<h2 id="what-is-a-pac"><a class="header" href="#what-is-a-pac">What is a PAC?</a></h2>
<p>Peripheral Access Crate (PAC) is how we access the peripherals of the microcontroller unit (MCU).
To use the peripherals, we need to assign ownership of the device peripherals. This is required in rust to manage memory.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let dp = pac::Peripherals::take().unwrap();
<span class="boring">}</span></code></pre></pre>
<p>From the device peripherals, we split out the struct gpioa, which is the GPIO group A on the microcontroller. We can see in the datasheet that this group contains pins 0-15 (PA0-15).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let gpioa = dp.GPIOA.split();
<span class="boring">}</span></code></pre></pre>
<p>We can assign a single pin to a variable and configure it, in this case we want to configure it into a push/pull output, to either connect our LED to power or ground.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut LD1 = gpioa.pa5.into_push_pull_output();
<span class="boring">}</span></code></pre></pre>
<p>Now that we have configured PA5 into a push/pull output with the name LD1, which correspondes with the LD1 LED on the ST NucleoF401RE board. We probably want to do something with it right?
We can turn it off, with the following commands:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    LD1.set_low();
    LD1.set_high();
<span class="boring">}</span></code></pre></pre>
<p>We also want it to blink, we can use <code>cortex_m::asm::delay(8_000_000);</code>, this simply pauses the program for 8 000 000 million clock cycles, and since our clock runs at 8MHz, that equates to 1 second.<br />
By adding a conversion factor, we can use milliseconds instead, giving us a simple blinky program:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Clock-cycles to millisecond conversion factor
let ms: u32 = 8_000;
    loop {
        // Wait 500ms
        cortex_m::asm::delay(500 * ms);

        // Turn on LED LD1
        LD1.set_high();

        // Wait 500ms
        cortex_m::asm::delay(500 * ms);

        // Turn off LED LD1
        LD1.set_low();   
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<p>Here is a complete code example, it is the default example, and can be run with:</p>
<pre><code class="language-sh">$ cargo embed --example blinky
</code></pre>
<pre><pre class="playground"><code class="language-rust">// ========================== Embedded Rust Set-up ==========================
#![deny(unsafe_code)]
#![no_main]
#![no_std]


// Imports
use defmt::*;
use defmt_rtt as _; // Global logger
use panic_probe as _; // Panic handler with defmt support
use cortex_m_rt::entry;
use stm32f4xx_hal::{
    pac::{self},
    prelude::*,
};


#[allow(non_snake_case)]
#[allow(clippy::empty_loop)]
#[entry]
fn main() -&gt; ! {
    // ========================== Set-up ==========================
    // Take ownership of device peripherals and split out GPIO group A and B
    let dp = pac::Peripherals::take().unwrap();
    let gpioa = dp.GPIOA.split();

    // Configure pins
    let mut LD1 = gpioa.pa5.into_push_pull_output();
    LD1.set_low();

    // Calculate conversion factor from clock cycles to ms, assuming 8 MHz
    let ms: u32 = 8_000;


   // ========================== LOOP ==========================
    loop {
        // Wait 500ms
        cortex_m::asm::delay(500 * ms);

        // Turn on LED LD1
        LD1.set_high();

        // Wait 500ms
        cortex_m::asm::delay(500 * ms);

        // Turn off LED LD1
        LD1.set_low();

        
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world-in-embedded-rust"><a class="header" href="#hello-world-in-embedded-rust">Hello World! In embedded rust!</a></h1>
<p>To print hello world to the user, we need a way to send serial messages, in this case we use the debugger probe-rs with defmt. You might say, but what about other debuggers like GBD or openOCD?
My answer is no, here we are going full rust, or get scuffed.</p>
<p>Add the debugger to our dependencies in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">Cargo.toml
[dependencies]
defmt = "1.0.1"
defmt-rtt = "1.0.0"
panic-probe = { version = "1.0.0", features = ["print-defmt"] }
</code></pre>
<p>Then we import the debugger into our main function, and use <code>info!</code> to to send a message to the terminal:</p>
<pre><pre class="playground"><code class="language-rust">main.rs
// Import defmt debugger
use defmt::*;         // Debugger
use defmt_rtt as _;   // Use defmt as global rtt logger
use panic_probe as _; // Panic handler with defmt support

#[entry] 
fn main() -&gt; ! {
    // Use info! to print a message to the terminal. 
    info!("Hello World!");

    loop {}
}</code></pre></pre>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<p>Here is a complete code example, it is the default example, and can be run with:</p>
<pre><code class="language-sh">$ cargo build
$ cargo embed
</code></pre>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

// Crates
use cortex_m_rt::entry; // ARM dependencies for cortex-m architecture
use stm32f4xx_hal as _; // STM32F4 series HAL crate

// Debugger
use defmt::*;
use defmt_rtt as _;     // Global logger
use panic_probe as _;   // Panic handler with defmt support


// MAIN
#[allow(clippy::empty_loop)] 
#[entry] 
fn main() -&gt; ! {
    info!("Use cargo embed --example &lt;example name&gt;, to build examples!");

    loop {}
}</code></pre></pre>
<p>Don't forget to have you STM32F4 connected! A terminal should open and look like this:
<img src="examples/../images/hello_world_terminal.png" alt="Hello World Terminal" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blinky-1"><a class="header" href="#blinky-1">Blinky</a></h1>
<p>Blinky will be our first attempt at using the STM32F4 HAL crate. We use this crate to access the peripherals of the STM32, safely wrapped in rust.</p>
<p>From the STM32F4 HAL we import the Peripheral Access Crate (PAC) and the preludes. The preludes import some generics and traits for embedded HAL that saves us some typing.
The PAC is how we access the peripherals of the microcontroller unit (MCU).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use stm32f4xx_hal::{
    pac::{self},
    prelude::*,
};
<span class="boring">}</span></code></pre></pre>
<h2 id="what-is-a-pac-1"><a class="header" href="#what-is-a-pac-1">What is a PAC?</a></h2>
<p>Peripheral Access Crate (PAC) is how we access the peripherals of the microcontroller unit (MCU).
To use the peripherals, we need to assign ownership of the device peripherals. This is required in rust to manage memory.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let dp = pac::Peripherals::take().unwrap();
<span class="boring">}</span></code></pre></pre>
<p>From the device peripherals, we split out the struct gpioa, which is the GPIO group A on the microcontroller. We can see in the datasheet that this group contains pins 0-15 (PA0-15).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let gpioa = dp.GPIOA.split();
<span class="boring">}</span></code></pre></pre>
<p>We can assign a single pin to a variable and configure it, in this case we want to configure it into a push/pull output, to either connect our LED to power or ground.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut LD1 = gpioa.pa5.into_push_pull_output();
<span class="boring">}</span></code></pre></pre>
<p>Now that we have configured PA5 into a push/pull output with the name LD1, which correspondes with the LD1 LED on the ST NucleoF401RE board. We probably want to do something with it right?
We can turn it off, with the following commands:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    LD1.set_low();
    LD1.set_high();
<span class="boring">}</span></code></pre></pre>
<p>We also want it to blink, we can use <code>cortex_m::asm::delay(8_000_000);</code>, this simply pauses the program for 8 000 000 million clock cycles, and since our clock runs at 8MHz, that equates to 1 second.<br />
By adding a conversion factor, we can use milliseconds instead, giving us a simple blinky program:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Clock-cycles to millisecond conversion factor
let ms: u32 = 8_000;
    loop {
        // Wait 500ms
        cortex_m::asm::delay(500 * ms);

        // Turn on LED LD1
        LD1.set_high();

        // Wait 500ms
        cortex_m::asm::delay(500 * ms);

        // Turn off LED LD1
        LD1.set_low();   
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example-2"><a class="header" href="#complete-example-2">Complete Example</a></h2>
<p>Here is a complete code example, it is the default example, and can be run with:</p>
<pre><code class="language-sh">$ cargo embed --example blinky
</code></pre>
<pre><pre class="playground"><code class="language-rust">// ========================== Embedded Rust Set-up ==========================
#![deny(unsafe_code)]
#![no_main]
#![no_std]


// Imports
use defmt::*;
use defmt_rtt as _; // Global logger
use panic_probe as _; // Panic handler with defmt support
use cortex_m_rt::entry;
use stm32f4xx_hal::{
    pac::{self},
    prelude::*,
};


#[allow(non_snake_case)]
#[allow(clippy::empty_loop)]
#[entry]
fn main() -&gt; ! {
    // ========================== Set-up ==========================
    // Take ownership of device peripherals and split out GPIO group A and B
    let dp = pac::Peripherals::take().unwrap();
    let gpioa = dp.GPIOA.split();

    // Configure pins
    let mut LD1 = gpioa.pa5.into_push_pull_output();
    LD1.set_low();

    // Calculate conversion factor from clock cycles to ms, assuming 8 MHz
    let ms: u32 = 8_000;


   // ========================== LOOP ==========================
    loop {
        // Wait 500ms
        cortex_m::asm::delay(500 * ms);

        // Turn on LED LD1
        LD1.set_high();

        // Wait 500ms
        cortex_m::asm::delay(500 * ms);

        // Turn off LED LD1
        LD1.set_low();

        
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="buten-controlled-light"><a class="header" href="#buten-controlled-light">Buten Controlled Light</a></h1>
<p>Being able to have some inputs would be nice right?
So lets try controlling the LED with the on-board button. Just like in the blinky example, we need to split out of peripherals. We also split out GPIO group C, since the on-board button B1, is connected to pin 13 in group C, PC13.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let dp = pac::Peripherals::take().unwrap();
    let gpioa = dp.GPIOA.split();
    let gpioc = dp.GPIOC.split();
<span class="boring">}</span></code></pre></pre>
<p>We then assign PC13 to B1. Notice here we don't need to declare B1 a mutable variable, since we only read data from it. (If we wanted to write to it, we had to make it mutable).<br />
We then check if B1 is true (high) using <code>.is_low()</code>, and set our LED LD1 high if it is.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let B1 = gpioc.pc13;

loop {
    // Check if button is pressed
    if B1.is_low() {
        LD1.set_high(); // Turn ON LED
    } else {
        LD1.set_low(); // Turn OFF LED
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example-3"><a class="header" href="#complete-example-3">Complete Example</a></h2>
<p>Here is a complete code example and can be run with:</p>
<pre><code class="language-sh">$ cargo embed --example buten
</code></pre>
<pre><pre class="playground"><code class="language-rust">// ========================== Embedded Rust Set-up ==========================
#![deny(unsafe_code)]
#![no_main]
#![no_std]


// Imports
use defmt_rtt as _; // Global logger
use panic_probe as _; // Panic handler with defmt support
use cortex_m_rt::entry;
use stm32f4xx_hal::{
    pac::{self},
    prelude::*,
};


#[allow(non_snake_case)]
#[allow(clippy::empty_loop)]
#[entry]
fn main() -&gt; ! {
    // ========================== Set-up ==========================
    // Take ownership of device peripherals and split out GPIO group A and B
    let dp = pac::Peripherals::take().unwrap();
    let gpioa = dp.GPIOA.split();
    let gpioc = dp.GPIOC.split();

    // Configure pins
    let mut LD1 = gpioa.pa5.into_push_pull_output();
    LD1.set_low();
    let B1 = gpioc.pc13;

   // ========================== LOOP ==========================
    loop {
        // Check if button is pressed
        if B1.is_low() {
            LD1.set_high(); // Turn ON LED
        } else {
            LD1.set_low(); // Turn OFF LED
        }
    }
}</code></pre></pre>
<p>(btw, buten is a inside joke, I am not illiterate)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dimming-a-led-using-pwm"><a class="header" href="#dimming-a-led-using-pwm">Dimming a LED using PWM</a></h1>
<p>Now lets try ourselvs at something a bit more advanced. A LED that is dimmed with the help of a button.
We will dim it using PWM, but before we can do this, we need to configure the clocks and timers, which in turn control our PWM.</p>
<p>We give ownership of the reset and clock control to <code>rcc</code>, from <code>dp</code>.<br />
Then configure(<code>.cfgr</code>) it from a high speed external(<code>use_hse()</code>) clock running at 8 MHz(<code>8.MHz()</code>) and lock the configuration(<code>.freeze()</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Configure clocks
    let rcc = dp.RCC.constrain();
    let clocks = rcc.cfgr.use_hse(8.MHz()).freeze();
<span class="boring">}</span></code></pre></pre>
<p>Now to the juicy part, we actually configure one of our timers (Timer 2, TIM2) for PWM.
To do this, we do this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Configure PWM
let (_, (LD1_pwm, ..)) = dp.TIM2.pwm_hz(2000.Hz(), &amp;clocks);
<span class="boring">}</span></code></pre></pre>
<p>So what is going on here?<br />
Here we take timer 2(<code>TIM2</code>) from the device peripheral handler(<code>dp</code>), and configure it for PWM with hertz as a input (<code>.pwm_hz()</code>). And set the PWM frequency to 2000 Hz (<code>.Hz()</code>), and use our on-board clock as a reference (<code>&amp;clocks</code>).<br />
Now why do we assign it to <code>(_, (LD1_pwm, ..))</code>?<br />
This is because it returns an array, where the first spot is the PWM controller, which we ignore with (<code>_</code>), then the second spot is all the PWM channels
<code>(LD1_pwm, ..))</code>. The first channel is assigned to <code>LD1_pwm</code>, while we ignore the rest with <code>, ..)</code>, it would be the same as putting <code>_</code> for all the other channels.
Can I do PWM now? No, have patience my child. We have our PWM channel, we now need to assign it to a suitable pin,
so we assign <code>LD1_pwm</code> to pin 5 in GPIO group A (<code>pa5</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut LD1_pwm = LD1_pwm.with(gpioa.pa5);
let max_duty = LD1_pwm.get_max_duty();
LD1_pwm.enable();
<span class="boring">}</span></code></pre></pre>
<p>We also use <code>.get_max_duty()</code> to get the maximum PWM value, and <code>.enable()</code> to enable the channel.</p>
<p>Finally, we can set the PWM duty cycle for PA5, we do this with <code>.set_duty()</code>, and give it a division of <code>max_duty</code>.<br />
In this case divided by 4 or 25% duty cycle.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>LD1_pwm.set_duty(max_duty / 4); // 25% duty for LED LD1. 
<span class="boring">}</span></code></pre></pre>
<p>Now lets make it even cooler. Lets have 10 levels (0-100%), controlled by a button!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Initialize counter variable
    let mut counter = 0;

    // Calculate conversion factor from clock cycles to ms, assuming 8 MHz
    let ms: u32 = 8_000;
    
   loop {
    if B1.is_low() {
        cortex_m::asm::delay(50 * ms); // debounce delay
        if B1.is_low() {
            counter = (counter + 1) % 11; // increment and roll over after 10 (0-10 total 11 states)

            // Wait until button released
            while B1.is_high() {}
        }
    }

    // Set PWM for LD1
    let duty = (max_duty * counter) / 10; // 10 steps (0%, 10%, ..., 100%)
    LD1_pwm.set_duty(duty);
}
<span class="boring">}</span></code></pre></pre>
<p>Here we initialize the counter and calculate the clock-cycle to ms factor.<br />
In the main loop we check if our button is pressed(<code>if B1.is_low()</code>), if it is, we wait for 50ms(<code>cortex_m::asm:delay(50*ms)</code>), then if it still is pressed, we increment the counter. The reason for the delay is a quick-and-dirty debounce of the button. To increment to counter from 0-10, we use this <code>counter = (counter + 1) % 11</code>. Then wait for the button to be unpressed (<code>while B1.is_high()</code>), so we don't increment more than once.</p>
<p>Outside the loop, we calculate the desired duty cycle from the counter and apply it to our LED, LD1.</p>
<h2 id="complete-example-4"><a class="header" href="#complete-example-4">Complete Example</a></h2>
<p>Here is a complete code example and can be run with:</p>
<pre><code class="language-sh">$ cargo embed --example pwm_dimmer
</code></pre>
<pre><pre class="playground"><code class="language-rust">// ========================== Embedded Rust Set-up ==========================
#![deny(unsafe_code)]
#![no_main]
#![no_std]


// Imports
use defmt_rtt as _; // Global logger
use panic_probe as _; // Panic handler with defmt support
use cortex_m_rt::entry;
use stm32f4xx_hal::{
    pac::{self},
    prelude::*,
};


#[allow(non_snake_case)]
#[allow(clippy::empty_loop)]
#[entry]
fn main() -&gt; ! {
    // ========================== Set-up ==========================
    // Take ownership of device peripherals and split out GPIO group A and B
    let dp = pac::Peripherals::take().unwrap();
    let gpioa = dp.GPIOA.split();
    let gpioc = dp.GPIOC.split();

    // Configure clocks
    let rcc = dp.RCC.constrain();
    let clocks = rcc.cfgr.use_hse(8.MHz()).freeze();

    // Configure pins
    let B1 = gpioc.pc13;

    // Configure PWM
    let (_, (LD1_pwm, ..)) = dp.TIM2.pwm_hz(2000.Hz(), &amp;clocks);
    let mut LD1_pwm = LD1_pwm.with(gpioa.pa5);
    let max_duty = LD1_pwm.get_max_duty();
    LD1_pwm.enable();

    // Initialize counter variable
    let mut counter = 0;

    // Calculate conversion factor from clock cycles to ms, assuming 8 MHz
    let ms: u32 = 8_000;
    

   // ========================== LOOP ==========================
   loop {
    if B1.is_low() {
        cortex_m::asm::delay(50 * ms); // debounce delay
        if B1.is_low() {
            counter = (counter + 1) % 11; // increment and roll over after 10 (0-10 total 11 states)

            // Wait until button released
            while B1.is_high() {}
        }
    }

    // Set PWM for LD1
    let duty = (max_duty * counter) / 10; // 10 steps (0%, 10%, ..., 100%)
    LD1_pwm.set_duty(duty);
}
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
